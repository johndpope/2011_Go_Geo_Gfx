package glsl

var VShaders = map[string]string {}
var FShaders = map[string]string {}

func init () {
	FShaders["canvas"] = "uniform vec2 uScreen;\nuniform sampler2D uTex0;\n\nout vec4 vCol;\n\nvoid main (void) {\n\tvCol = texture(uTex0, uScreen * gl_FragCoord.xy);\n\tvCol.a = 1;\n}\n"
	VShaders["ppquad"] = "void main (void) {\n\t//const vec2 aPos = vec2((4 * (gl_VertexID % 2)) - 1, (4 * (gl_VertexID / 2)) - 1);\n\t//vPos = (aPos + 1) / 2;\n\t// vPos.y = -vPos.y;\n\tgl_Position = vec4((4 * (gl_VertexID % 2)) - 1, (4 * (gl_VertexID / 2)) - 1, 0, 1);\n}\n"
	FShaders["cast"] = "in vec3 vRayDir;\n\nuniform vec3 uCamPos;\nuniform vec2 uScreen;\n\nout vec3 vFragColor;\n\n//Simple raymarching sandbox with camera\n\n//Raymarching Distance Fields\n//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n//Also known as Sphere Tracing\n\n//Util Start\nvec2 ObjUnion(in vec2 obj0,in vec2 obj1){\n  if (obj0.x<obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n//Util End\n\n//Scene Start\n\n//Floor\nvec2 obj0(in vec3 p){\n  return vec2(p.y+3.0,0);\n}\n//Floor Color (checkerboard)\nvec3 obj0_c(in vec3 p){\n if (fract(p.x*.5)>.5)\n   if (fract(p.z*.5)>.5)\n     return vec3(0,0,0);\n   else\n     return vec3(1,1,1);\n else\n   if (fract(p.z*.5)>.5)\n     return vec3(1,1,1);\n   else\n     \treturn vec3(0,0,0);\n}\n\n//IQs RoundBox (try other objects http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nvec2 obj1(in vec3 p){\n  return vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\n//RoundBox with simple solid color\nvec3 obj1_c(in vec3 p){\n\treturn vec3(1.0,0.0,0.0);\n}\n\n//Objects union\nvec2 inObj(in vec3 p){\n  return ObjUnion(obj0(p),obj1(p));\n}\n\n//Scene End\n\nvoid main(void){\n\t/*\n  vec2 vPos=-1.0+2.0*gl_FragCoord.xy*uScreen.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,1,0);//Change camere up vector here\n  vec3 vrp=vec3(0,0,0); //Change camere view here\n  vec3 prp=vec3(-sin(uTime)*8.0,4,cos(uTime)*8.0); //Change camera path position here\n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*(uScreen.y/uScreen.x)+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n*/\n\tconst vec3 prp = uCamPos;\n\tconst vec3 scp = vRayDir;\n  //Raymarching\n  const vec3 e=vec3(0.1,0,0);\n  const float maxd=60.0; //Max depth\n  float fDelt = 0.01;\n\n  vec2 s=vec2(0.1,0.0);\n  vec3 c,p,n;\n\n  float f=1.0;\n  for(int i=0;i<256;i++){\n    if (abs(s.x)<.01||f>maxd) break;\n    f+=s.x;\n    p=prp+scp*(f + fDelt);\n    fDelt = 0.01 * f;\n    s=inObj(p);\n  }\n  \n  if (f<maxd){\n    if (s.y==0.0)\n      c=obj0_c(p);\n    else\n      c=obj1_c(p);\n    n=normalize(\n      vec3(s.x-inObj(p-e.xyy).x,\n           s.x-inObj(p-e.yxy).x,\n           s.x-inObj(p-e.yyx).x));\n    float b=dot(n,normalize(prp-p));\n    vFragColor = vec3((b*c+pow(b,8.0))*(1.0-f*.01));//simple phong LightPosition=CameraPosition\n  }\n  else vFragColor=vec3(0,0,0); //background color\n}"
	VShaders["cast"] = "uniform vec3 uCamLook;\nuniform vec3 uCamPos;\nuniform vec2 uScreen;\n\nout vec3 vRayDir;\n\nvoid main (void) {\n\tvec2 vPos = vec2((4 * (gl_VertexID % 2)) - 1, (4 * (gl_VertexID / 2)) - 1);\n\t// vPos.y = -vPos.y;\n\tgl_Position = vec4(vPos.xy, 0, 1);\n\tvPos = (vPos + 1) * 0.5;\n\n\tconst vec2 vViewPlane = ((vPos * 2) - 1) / vec2(1, uScreen.y / uScreen.x);\n\tconst vec3 vForwards = normalize(uCamLook - uCamPos);\n\tconst vec3 vRight = normalize(cross(vForwards, vec3(0, 1, 0)));\n\tconst vec3 vUp = cross(vRight, vForwards);\n\tvRayDir = (-vRight * vViewPlane.x) + (vUp * vViewPlane.y) + vForwards;\n}\n"
	FShaders["ppblur"] = "in vec2 vPos;\n\nuniform vec2 uScreen;\nuniform sampler2D uTex0;\n\nuniform float[] fOffsets = float[] (0, 1.3846153846, 3.2307692308);\nuniform float[] fWeights = float[] (0.2270270270, 0.3162162162, 0.0702702703);\n\nout vec3 vCol;\n\nvoid main (void) {\n\tvCol = texture(uTex0, vPos).rgb * fWeights[0];\n\tfor (int i = 1; i < 3; i++) {\n\t\tvCol += (texture(uTex0, vPos + vec2(fOffsets[i] * uScreen.x, fOffsets[i] * uScreen.y)).rgb * fWeights[i]);\n\t\tvCol += (texture(uTex0, vPos - vec2(fOffsets[i] * uScreen.x, fOffsets[i] * uScreen.y)).rgb * fWeights[i]);\n\t}\n}\n"
	FShaders["postfx"] = "uniform vec2 uScreen;\nuniform sampler2D uTex0;\nuniform sampler2D uTex1;\n\nout vec3 vCol;\n\nconst vec3 VNULL = vec3(0);\n\nvoid Bleach () {\n\tconst float fBleachAmount = 2;\n\tconst vec3 vCoeff = vec3(0.2125, 0.7154, 0.0721);\n\tconst float fLum = max(0.001, dot(vCol.rgb, vCoeff));\n\tconst vec3 vLum = vec3(fLum);\n\tconst float fMix = clamp((fLum - 0.4) * 10, 0, 1);\n\tconst vec3 vB1 = 2 * vCol * vLum;\n\tconst vec3 vB2 = 1 - (2 * (1 - vCol) * (1 - vLum));\n\tconst vec3 vMix = mix(vB1, vB2, fMix);\n\tvCol = mix(vCol, vMix, fBleachAmount);\n}\n\nvoid BlueShift () {\n\tvCol = mix(vCol, vCol * vec3(1.05, 0.97, 1.27), 0.33);\n}\n\nvoid Colorful () {\n\tvCol *= step(0.05, vCol);\n}\n\nvoid Defog () {\n\tconst vec3 vDefog = vec3(0);\n\tconst vec3 vColor = vec3(0);\n\tvCol = max(VNULL, vCol - (vDefog * vColor));\n}\n\nfloat log10 (const in float fVal) {\n\treturn log2(fVal) * log2(10);\n}\n\nvoid Exposure (/*const in vec3 vLum*/) {\n\treturn;\n//\tconst float fLumPixel = max(0.0001, dot(vCol, vec3(0.2126, 0.7152, 0.0722/*0.299, 0.587, 0.114*/)));\n//\tconst float fMean = max(0.0001, exp(vLum.r + 0.0001));\n//\tconst float fMidGrey = max(0, 1.5 - (1.5 / ((fMean * 0.1) + 1))) + 0.1;\n//\tconst float fLumScaled = fMidGrey * (fLumPixel / fMean);\n//\tconst float fMidGrey = 1.03 - (2 / (2 + log10(fMean + 1)));\n//\tconst float fLumScaled = (fLumPixel * fMidGrey) / fMean;\n//\tconst float fLumMapped = fLumScaled / (1 + fLumScaled);\n\n//\tconst float fLin = fMidGrey / fMean;\n//\tconst float fExposure = (max(fLin, 0.0001));\n//\tvCol *= exp2(fExposure);\n}\n\nvoid Grayscale () {\n\tvCol = vec3(dot(vCol, vec3(0.222, 0.707, 0.071)));\n\t// vCol = vec3((vCol.r + vCol.g + vCol.b) / 3);\n}\n\nvec3 Tonemap (const in vec3 vColor) {\n\tconst float fShoulder = 0.33; // 0.22 // 0.15;\n\tconst float fLinStrength = 0.2; // 0.30 // 0.50;\n\tconst float fLinAngle = 0.1; // 0.10 // 0.10\n\tconst float fToeStrength = 0.20; // 0.20 // 0.20\n\tconst float fToeNumerator = 0.001; // 0.01 // 0.02;\n\tconst float fToeDenominator = 0.20; // 0.30 // 0.33\n\treturn ((vColor * ((fShoulder * vColor) + (fLinAngle * fLinStrength)) + (fToeStrength * fToeNumerator)) / (vColor * ((fShoulder * vColor) + fLinStrength) + (fToeStrength * fToeDenominator))) - (fToeNumerator / fToeDenominator);\n}\n\nvoid Tonemap () {\n\tconst vec3 vNumerator = Tonemap(vCol * 1);\n\tconst vec3 vDenominator = Tonemap(vec3(11.2));\n\tvCol = vNumerator / vDenominator;\n}\n\nvoid Vignette () {\n\tconst float fAmount = -2; // -2 darkest, >0 whitening\n\tconst float fRadius = 0.88;\n\tconst vec2 vCenter = vec2(0.5);\n\t// vCol += (fAmount * pow(length(vPos - vCenter) / fRadius, 4));\n}\n\nvoid main () {\n//\tconst float fBloom = 0.4;\n\tconst vec2 vPos = uScreen * gl_FragCoord.xy;\n//\tconst vec3 vBloom = texture(uTex1, vPos).rgb;\n//\tconst vec3 vLum = texture(uTex1, vec2(0.5, 0.5)).rgb;\n\tvCol = texture(uTex0, vPos).rgb;\n\t//const float fFragLum = dot(vCol.rgb, vec3(0.299, 0.587, 0.114));\n//\tvCol = mix(vCol, vBloom * 1, fBloom);\n\t//if (vPos.x > 0.25)\n\tExposure();\n\t//if (vPos.x > 0.45)\n\tTonemap();\n/*\n\tif (vPos.y < 0.05)\n\t\tvCol = vec3(exp(vLum.r));\n\telse if (vPos.y < 0.1)\n\t\tvCol = vec3(fExp / 10);\n*/\n}\n"
	FShaders["ppbright"] = "uniform vec2 uScreen;\nuniform sampler2D uTex0;\nuniform sampler2D uTex1;\n\nout vec3 vCol;\n\nvoid main (void) {\n\tvCol = texture(uTex0, gl_FragCoord.xy * uScreen).rgb;\n\tvCol *= step(1, dot(vCol.rgb, vec3(0.299, 0.587, 0.114)));\n\t// vCol = vTexCol.rgb * step(vec3(1), vTexCol.rgb);\n\t/*\n\tif (vTexCol.r > 1 || vTexCol.g > 1 || vTexCol.b > 1) {\n\t\tvCol = vTexCol.rgb;\n\t} else {\n\t\tvCol = vec3(0);\n\t}\n\t/*\n\tconst float fExposure = 1;\n\tconst float fThreshold = 0.5;\n\tconst vec4 vTexCol = texture(uTex0, vPos);\n\tconst vec2 vLum = texture(uTex1, vec2(0.5, 0.5)).rg;\n\tconst float fScaleLum = (vTexCol.a * fExposure) / vLum.r;\n\tvCol = max(vec3(0), (vTexCol.rgb * ((fScaleLum * (1 + (fScaleLum / (vLum.g * vLum.g)))) / (1 + fScaleLum))) - fThreshold);\n\t*/\n}\n"
	VShaders["ppblur"] = "out vec2 vPos;\n\nvoid main (void) {\n\tconst vec2 aPos = vec2((4 * (gl_VertexID % 2)) - 1, (4 * (gl_VertexID / 2)) - 1);\n\tvPos = (aPos + 1) / 2;\n\tgl_Position = vec4(aPos, 0, 1);\n}\n"
	FShaders["texture"] = "uniform vec2 uScreen;\nuniform sampler2D uTex0;\n\nout vec3 vCol;\n\nvoid main (void) {\n\tvCol = texture(uTex0, gl_FragCoord.xy * uScreen).rgb;\n}\n"
	FShaders["pplum2"] = "uniform vec4 uScreen;\nuniform sampler2D uTex0;\n\nout vec3 vLum;\n\nvoid main (void) {\n\tconst vec2 vOffset = vec2(-0.5, 0.5);\n\tconst vec2 vPos = gl_FragCoord.xy * uScreen.xy;\n\tfloat fGray;\n\tfloat fAvg = 0;\n\tfloat fMax = -1e20;\n\tfloat fMin = 1e19;\n\n\tfor (int x = 0; x < 2; x++) {\n\t\tfor (int y = 0; y < 2; y++) {\n\t\t\tfGray = dot(texture(uTex0, vPos + vec2(vOffset[x] * uScreen[2], vOffset[y] * uScreen[3])).rgb, vec3(0.299, 0.587, 0.114));\n\t\t\tfAvg += log(0.0001 + fGray);\n\t\t\tfMax = max(fMax, fGray);\n\t\t\tfMin = min(fMin, fGray);\n\t\t}\n\t}\n\tvLum = vec3(fAvg / 4, fMax, fMin);\n}\n"
	FShaders["pplum3"] = "uniform vec4 uScreen;\nuniform sampler2D uTex0;\n\nout vec3 vLum;\n\nvoid main (void) {\n\tconst vec3 vOffset = vec3(-0.5, 0, 0.5);\n\tconst vec2 vPos = gl_FragCoord.xy * uScreen.xy;\n\tbool bLast = (uScreen[2] == 3);\n\tvec2 vOff;\n\tvec3 vMidMax;\n\tfloat fAvg = 0;\n\tfloat fMax = -1e20;\n\tfloat fMin = 1e19;\n\n\tfor (int x = 0; x < 3; x++) {\n\t\tfor (int y = 0; y < 3; y++) {\n\t\t\tif (bLast) {\n\t\t\t\tvOff = vec2(x * 0.49999998, y * 0.49999998);\n\t\t\t\tvMidMax = texture(uTex0, vOff).rgb;\n\t\t\t} else {\n\t\t\t\tvOff = vec2(vOffset[x] * uScreen[2], vOffset[y] * uScreen[3]);\n\t\t\t\tvMidMax = texture(uTex0, vPos + vOff).rgb;\n\t\t\t}\n\t\t\tfAvg += vMidMax.r;\n\t\t\tfMax = max(fMax, vMidMax.g);\n\t\t\tfMin = min(fMin, vMidMax.b);\n\t\t}\n\t}\n\tvLum = vec3(fAvg / 9, fMax, fMin);\n}\n"
}
